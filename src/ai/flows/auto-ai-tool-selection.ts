
// AutoAIToolSelection flow
'use server';
/**
 * @fileOverview Automatically selects the best AI tool based on the complexity and context of the query.
 *
 * - autoAIToolSelection - A function that automatically selects an AI tool and returns its response.
 * - AutoAIToolSelectionInput - The input type for the autoAIToolSelection function.
 * - AutoAIToolSelectionOutput - The return type for the autoAIToolSelection function.
 */

import {ai} from '@/ai/genkit';
import { sendMessageAction } from '@/app/actions';
import {z} from 'genkit';

const AutoAIToolSelectionInputSchema = z.object({
  query: z.string().describe('The user query to be processed by the AI tool.'),
  userId: z.string().describe('The ID of the user making the query.'),
});
export type AutoAIToolSelectionInput = z.infer<typeof AutoAIToolSelectionInputSchema>;

const AutoAIToolSelectionOutputSchema = z.object({
  tool: z.string().describe('The AI tool that was automatically selected.'),
  response: z.string().describe('The response generated by the selected AI tool.'),
  rawResponse: z.string().optional().describe('The raw response from the AI provider, for debugging.'),
});
export type AutoAIToolSelectionOutput = z.infer<typeof AutoAIToolSelectionOutputSchema>;

export async function autoAIToolSelection(input: AutoAIToolSelectionInput): Promise<AutoAIToolSelectionOutput> {
  return autoAIToolSelectionFlow(input);
}

const selectAITool = ai.defineTool({
  name: 'selectAITool',
  description: 'Selects the most appropriate AI tool based on the complexity and context of the user query, considering cost, latency and quality requirements.',
  inputSchema: z.object({
    query: z.string().describe('The user query to be processed.'),
  }),
  outputSchema: z.enum(['GPT', 'Gemini', 'Purplexcity', 'Grok', 'Deepseek', 'FreeTool']),
}, async (input) => {
  // This is a placeholder; a more sophisticated implementation could use an LLM
  // to classify the query and select the best tool.
  // For now, we'll default to Gemini as it doesn't require a pre-saved API key to work.
  if(input.query.length < 50) {
      return 'FreeTool'
  }
  return 'Gemini';
});

const generateResponse = ai.defineTool({
  name: 'generateResponse',
  description: 'Generates a response to the user query using the specified AI tool.',
  inputSchema: z.object({
    query: z.string().describe('The user query.'),
    tool: z.string().describe('The AI tool to use for generating the response.'),
    userId: z.string().describe('The ID of the user making the query.'),
  }),
  outputSchema: z.object({
    response: z.string().describe('The response generated by the AI tool.'),
    rawResponse: z.any().optional().describe('The raw response from the AI provider, for debugging.'),
  }),
}, async (input) => {
    // This tool now directly calls the main sendMessageAction, which contains the logic
    // for all API providers. This removes the need for a separate backend.
    const result = await sendMessageAction({
        prompt: input.query,
        tool: input.tool,
        userId: input.userId,
        // The auto-tool selector does not use pre-saved API keys. 
        // It relies on tools that may have keys in the environment.
    });

    if(!result.success || !result.aiResponse){
        throw new Error(result.error || "Failed to generate response.");
    }
    
    return {
        response: result.aiResponse.response,
        rawResponse: result.aiResponse.rawResponse
    };
});

const autoAIToolSelectionFlow = ai.defineFlow({
  name: 'autoAIToolSelectionFlow',
  inputSchema: AutoAIToolSelectionInputSchema,
  outputSchema: AutoAIToolSelectionOutputSchema,
  tools: [selectAITool, generateResponse],
}, async (input) => {
  const selectedTool = await selectAITool({ query: input.query });
  const {response, rawResponse} = await generateResponse({ query: input.py, tool: selectedTool, userId: input.userId });

  return {
    tool: selectedTool,
    response: response,
    rawResponse: typeof rawResponse === 'string' ? rawResponse : JSON.stringify(rawResponse, null, 2),
  };
});
