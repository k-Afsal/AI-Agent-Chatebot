
// AutoAIToolSelection flow
'use server';
/**
 * @fileOverview Automatically selects the best AI tool based on the complexity and context of the query.
 *
 * - autoAIToolSelection - A function that automatically selects an AI tool and returns its response.
 * - AutoAIToolSelectionInput - The input type for the autoAIToolSelection function.
 * - AutoAIToolSelectionOutput - The return type for the autoAIToolSelection function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const AutoAIToolSelectionInputSchema = z.object({
  query: z.string().describe('The user query to be processed by the AI tool.'),
  userId: z.string().describe('The ID of the user making the query.'),
  selectedTool: z.string().describe('The tool selected by the user. Can be "Auto".')
});
export type AutoAIToolSelectionInput = z.infer<typeof AutoAIToolSelectionInputSchema>;

// The output now just returns the selected tool, as the response is mocked.
const AutoAIToolSelectionOutputSchema = z.object({
  tool: z.string().describe('The AI tool that was automatically selected.'),
  response: z.string().describe('The response generated by the selected AI tool.'),
  rawResponse: z.string().optional().describe('The raw response from the AI provider, for debugging.'),
});
export type AutoAIToolSelectionOutput = z.infer<typeof AutoAIToolSelectionOutputSchema>;

export async function autoAIToolSelection(input: AutoAIToolSelectionInput): Promise<AutoAIToolSelectionOutput> {
  return autoAIToolSelectionFlow(input);
}

const selectAITool = ai.defineTool({
  name: 'selectAITool',
  description: 'Selects the most appropriate AI tool based on the complexity and context of the user query.',
  inputSchema: z.object({
    query: z.string().describe('The user query to be processed.'),
  }),
  outputSchema: z.enum(['GPT', 'Gemini', 'Purplexcity', 'Grok', 'Deepseek', 'FreeTool']),
}, async (input) => {
    const llmResponse = await ai.generate({
        prompt: `Based on the following user query, which AI tool would be the most appropriate to use?

        User Query: "${input.query}"

        Available Tools:
        - GPT: Best for complex reasoning, and creative text generation.
        - Gemini: A powerful, general-purpose model good for a wide range of tasks.
        - Purplexcity: Specialized in search and information retrieval.
        - Grok: Good for conversational AI and humor.
        - Deepseek: Strong in coding and technical queries.
        - FreeTool: A simple, free tool for basic questions.

        Select one tool from the list above.`,
        model: 'googleai/gemini-2.5-flash',
    });
    const selectedTool = llmResponse.text.trim();
    const validTools = ['GPT', 'Gemini', 'Purplexcity', 'Grok', 'Deepseek', 'FreeTool'];
    if (validTools.includes(selectedTool)) {
        return selectedTool as any;
    }
    return 'FreeTool'; // Default fallback
});


const autoAIToolSelectionFlow = ai.defineFlow({
  name: 'autoAIToolSelectionFlow',
  inputSchema: AutoAIToolSelectionInputSchema,
  outputSchema: AutoAIToolSelectionOutputSchema,
}, async (input) => {
  let finalTool = input.selectedTool;

  if (finalTool === 'Auto') {
    finalTool = await selectAITool({ query: input.query });
  }

  // For now, regardless of the tool selected, we'll use the default AI model to generate a response.
  // In a real application, you would have different logic here to call the specific API for each tool.
  const llmResponse = await ai.generate({
    prompt: `Using the persona of the ${finalTool} tool, answer the following query: ${input.query}`,
  });

  const response = llmResponse.text;

  return {
    tool: finalTool,
    response: response,
    rawResponse: JSON.stringify(llmResponse.output, null, 2),
  };
});
